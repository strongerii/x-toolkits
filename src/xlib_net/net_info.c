#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <getopt.h>
#include <sched.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <errno.h>//strerror(errno)
#include "net_info.h"


#define DEF_DNS_CFG_FILE			"/etc/resolv.conf"
#define DEF_NET_CFG_FILE			"/etc/network/interfaces"

int save_dns_info(const char *pPrimary, const char *pSecond)
{
	FILE *fp = NULL;
	if(NULL == pPrimary ||
		NULL == pSecond){
		return -1;
	}
	fp = fopen(DEF_DNS_CFG_FILE, "w");
	if(NULL == fp){
		printf(" fopen read %s failed\n", DEF_DNS_CFG_FILE);
		return -1;
	}
	//#
	fprintf(fp, "%s", "# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)\n");
	fprintf(fp, "%s", "#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN\n");
	fprintf(fp, "%s", "\n");
	//dns
	fprintf(fp, "nameserver %s\n", pPrimary);
	fprintf(fp, "nameserver %s\n", pSecond);
	fprintf(fp, "%s", "\n");

	fclose(fp);
	return 0;
}

int save_net_info(XLIB_NETWORKINFO *pNetInfo)
{
	FILE *fp = NULL;
	if(NULL == pNetInfo){
		return -1;
	}
	fp = fopen(DEF_NET_CFG_FILE, "w");
	if(NULL == fp){
		printf(" fopen read %s failed\n", DEF_NET_CFG_FILE);
		return -1;
	}
	//#
	fprintf(fp, "%s", "# interfaces(5) file used by ifup(8) and ifdown(8)\n");
	fprintf(fp, "%s", "\n");
	//lo
	fprintf(fp, "%s", "auto lo\n");
	fprintf(fp, "%s", "iface lo inet loopback\n");
	fprintf(fp, "%s", "\n");
	//eth 0
	fprintf(fp, "auto %s\n", pNetInfo->szEthName);
	fprintf(fp, "iface %s inet %s\n", pNetInfo->szEthName, pNetInfo->dhcpEnable ? "dhcp" : "static");
	fprintf(fp, "address %s\n", pNetInfo->szIP);
	fprintf(fp, "gateway %s\n", pNetInfo->szGateWay);
	fprintf(fp, "netmask %s\n", pNetInfo->szSubMsk);
	fprintf(fp, "%s", "\n");

	fclose(fp);

	//save dns
	save_dns_info((char*)pNetInfo->szFirstDns, (char*)pNetInfo->szSecDns);

	return 0;
}
/////////////////////////////////////////////////////////////////////
//set local ip
int set_localdhcp()
{
	int ret = 0;      
    char cmd[128] = {0};  

    strcpy(cmd, "/etc/init.d/S40network restart");  
      
    ret = system(cmd);  
    if(ret < 0)  
    {  
        perror("dhcp error\n");  
        return -1;  
    }  
  	return 0;

}

//get local ip address
int get_localip(const char *ifname,char *szNetIP, int len)
{
	int sock_get_ip;  
	char ipaddr[50];  
	struct   sockaddr_in *sin;  
	struct   ifreq ifr_ip;   

	if(NULL == ifname || NULL == szNetIP || len <= 0){
		return -1;
	}

	if ((sock_get_ip=socket(AF_INET, SOCK_STREAM, 0)) == -1)  
	{  
		printf("socket create failse...GetLocalIp!\n");  
		return -1;  
	}  

	memset(&ifr_ip, 0, sizeof(ifr_ip));     
	strncpy(ifr_ip.ifr_name, ifname, sizeof(ifr_ip.ifr_name) - 1);     

	if( ioctl( sock_get_ip, SIOCGIFADDR, &ifr_ip) < 0 )     
	{     
		return -1;     
	}       
	sin = (struct sockaddr_in *)&ifr_ip.ifr_addr;     
	strcpy(ipaddr,inet_ntoa(sin->sin_addr));         

	//printf("local ip:%s \n",ipaddr);      
	close( sock_get_ip );  
	
	if(len > strlen(ipaddr)){
		memset(szNetIP, 0, len);
		memcpy(szNetIP, ipaddr, strlen(ipaddr));
	 }
	
	return 0;  
}
//set local ip
int set_localip(const char *ifname,const char *szNetIP)
{
	int sock_set_ip;  

	struct sockaddr_in sin_set_ip;  
	struct ifreq ifr_set_ip;  

	if(NULL == ifname || NULL == szNetIP ){
		return -1;
	}

	bzero( &ifr_set_ip,sizeof(ifr_set_ip));

	printf("set_localip eth %s, ip %s\n", ifname, szNetIP);

	if( szNetIP == NULL ) { 
		return -1;  
	}
	sock_set_ip = socket( AF_INET, SOCK_STREAM, 0 ) ;
	if( sock_set_ip == -1 )  
	{  
		printf("socket create failse...SetLocalIp!err=%s\n", strerror(errno));  
		return -1;  
	}  
   
	memset( &sin_set_ip, 0, sizeof(sin_set_ip));  
	strncpy(ifr_set_ip.ifr_name, ifname, sizeof(ifr_set_ip.ifr_name)-1);     

	sin_set_ip.sin_family = AF_INET;  
	sin_set_ip.sin_addr.s_addr = inet_addr(szNetIP);  
	memcpy( &ifr_set_ip.ifr_addr, &sin_set_ip, sizeof(sin_set_ip));  

	if( ioctl( sock_set_ip, SIOCSIFADDR, &ifr_set_ip) < 0 )  
	{  
		printf( "Not setup interface err=%s\n", strerror(errno));  
		return -1;  
	}  

	ifr_set_ip.ifr_flags |= IFF_UP |IFF_RUNNING;  
	//get the status of the device  
	if( ioctl( sock_set_ip, SIOCSIFFLAGS, &ifr_set_ip ) < 0 )  
	{  
		printf( "SIOCSIFFLAGS err=%s\n", strerror(errno)); 
		return -1;  
	}  
	
	close( sock_set_ip );  
	return 0;

}

//get local mac
int get_localmac(const char *ifname,char *szNetMac, int len)
{
    int sock_mac;  
      
    struct ifreq ifr_mac;  
    char mac_addr[30] = {0};  
	
    if(NULL == ifname || NULL == szNetMac || len <=0 ){
	return -1;
    }

    sock_mac = socket( AF_INET, SOCK_STREAM, 0 );  
    if( sock_mac == -1)  
    {  
        perror("create socket falise...mac\n");  
        return -1;  
    }  
      
    memset(&ifr_mac,0,sizeof(ifr_mac));     
    strncpy(ifr_mac.ifr_name, ifname, sizeof(ifr_mac.ifr_name)-1);     
  
    if( (ioctl( sock_mac, SIOCGIFHWADDR, &ifr_mac)) < 0)  
    {  
        printf("mac ioctl error\n");  
        return -1;  
    }      
      
    close( sock_mac );

    sprintf(mac_addr, "%02X:%02X:%02X:%02X:%02X:%02X",
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[0],
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[1],
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[2],
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[3],
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[4],
	(unsigned char)ifr_mac.ifr_hwaddr.sa_data[5]);

    if(len > strlen(mac_addr) && szNetMac){
		memset(szNetMac, 0, len);
		memcpy(szNetMac, mac_addr, strlen(mac_addr));
    }
      
    return 0; 
}

//set local mac
int set_localmac(const char *ifname,const char *szNetMac)
{
	
	int ret = 0;      
	char cmd[128] = {0};  
	if(NULL == ifname || NULL == szNetMac ){
		return -1;
	}
	sprintf(cmd, "ifconfig %s  down", ifname);
	ret = system(cmd);  
	if(ret < 0)  
	{  
		perror("setlocalmac down error\n");  
		return -1;  
	} 

	sprintf(cmd, "ifconfig %s  hw ether %s", ifname, szNetMac);
	ret = system(cmd);  
	if(ret < 0)  
	{  
		perror("setlocalmac error\n");  
		return -1;  
	}  

	sprintf(cmd, "ifconfig %s  up", ifname);
	ret = system(cmd);  
	if(ret < 0)  
	{  
		perror("setlocalmac up error\n");  
		return -1;  
	} 
	return 0;
	
}
//get sub net mask
int get_netmask(const char *ifname,char *szNetMask, int len)
{
    int sock_netmask;  
    char netmask_addr[50];  
  
    struct ifreq ifr_mask;  
    struct sockaddr_in *net_mask; 
	
    if(NULL == ifname || NULL == szNetMask || len <=0 ){
	return -1;
    }     

    sock_netmask = socket( AF_INET, SOCK_STREAM, 0 );  
    if( sock_netmask == -1)  
    {  
        perror("create socket failture...GetLocalNetMask/n");  
        return -1;  
    }  
      
    memset(&ifr_mask, 0, sizeof(ifr_mask));     
    strncpy(ifr_mask.ifr_name, ifname, sizeof(ifr_mask.ifr_name )-1);     
  
    if( (ioctl( sock_netmask, SIOCGIFNETMASK, &ifr_mask ) ) < 0 )   
    {  
        printf("mac ioctl error\n");  
        return -1;  
    }  
      
    net_mask = ( struct sockaddr_in * )&( ifr_mask.ifr_netmask );  
    strcpy( netmask_addr, inet_ntoa( net_mask -> sin_addr ) );  
      
    //printf("local netmask:%s\n",netmask_addr);      
      
    close( sock_netmask );  

    if(len > strlen(netmask_addr) && szNetMask){
	memset(szNetMask, 0, len);
	memcpy(szNetMask, netmask_addr, strlen(netmask_addr));
     }
      
    return 0; 

}

//set sub net mask
int set_netmask(const char *ifname,const char *szNetMask)
{
    int sock_netmask;     
 
    struct ifreq ifr_mask;  
    struct sockaddr_in *sin_net_mask;  
	
    if(NULL == ifname || NULL == szNetMask  ){
	return -1;
    }  
		  
    sock_netmask = socket( AF_INET, SOCK_STREAM, 0 );  
    if( sock_netmask == -1)  
    {  
        perror("Not create network socket connect\n");  
        return -1;  
    }  
      
    memset(&ifr_mask, 0, sizeof(ifr_mask));     
    strncpy(ifr_mask.ifr_name, ifname, sizeof(ifr_mask.ifr_name )-1);     
    sin_net_mask = (struct sockaddr_in *)&ifr_mask.ifr_addr;  
    sin_net_mask -> sin_family = AF_INET;  
    inet_pton(AF_INET, szNetMask, &sin_net_mask ->sin_addr);  
  
    if(ioctl(sock_netmask, SIOCSIFNETMASK, &ifr_mask ) < 0)   
    {  
        printf("sock_netmask ioctl error\n");  
        return -1;  
    }  
    return 0;
}

//get default gateway
int get_gateway(char *szGateWay, int len)  
{  
    FILE *fp = NULL;  
    char buf[512] = {0};  
    char cmd[128] = {0};  
    char gateway[30] = {0};  
    char *tmp = NULL;  
	
     if(NULL == szGateWay || len <=0  ){
	return -1;
    }  
	  
    strcpy(cmd, "ip route");  
    fp = popen(cmd, "r");  
    if(NULL == fp)  
    {  
        perror("popen error\n");  
        return -1;  
    }  
    while(fgets(buf, sizeof(buf), fp) != NULL)  
    {  
        tmp =buf;  
        while(*tmp && isspace(*tmp))  
            ++ tmp;  
        if(strncmp(tmp, "default", strlen("default")) == 0)  
            break;  
    }  
    sscanf(buf, "%*s%*s%s", gateway);         
    //printf("default gateway:%s\n", gateway);  
    pclose(fp);  

    if(len > strlen(gateway) && szGateWay){
	memset(szGateWay, 0, len);
	memcpy(szGateWay, gateway, strlen(gateway));
     }
      
    return 0;  
} 
//set default gateway
int set_gateway(const char *szGateWay)
{
    int ret = 0;      
    char cmd[128] = {0};  
    char gateway[30] = {0};  
	 
     if(NULL == szGateWay){
	return -1;
    }  
	 
    if(get_gateway(gateway, sizeof(gateway)) < 0){
	perror("GetGateWay error\n");  
	return -1;
    }
      
    strcpy(cmd, "route del default gw ");  
    strcat(cmd, gateway);  
    ret = system(cmd);  
    if(ret < 0)  
    {  
        perror("route error\n");  
        return -1;  
    }  
    strcpy(cmd, "route add default gw ");  
    strcat(cmd, szGateWay);  
      
    ret = system(cmd);  
    if(ret < 0)  
    {  
        perror("route error\n");  
        return -1;  
    }  
  
    return ret; 
}

//get dns address
int get_dnsaddress(char *pPrimary, const int nPrimLen, char *pSecond, const int nSecLen)
{
	FILE *fp;
	char *tmp = NULL;
	char sline[512] = {0};
	int nsize = strlen("255.255.255.255");
	if(nPrimLen < nsize || nSecLen < nsize){
		printf("nPrimLen %d || nSecLen %d  < %d failed\n", nPrimLen, nSecLen,nsize);
		return -1;
	}

	memset(pPrimary, 0, sizeof(nPrimLen));
	memset(pSecond, 0, sizeof(nSecLen));

	fp = fopen(DEF_DNS_CFG_FILE, "r");
	if(NULL == fp){
		printf(" fopen read %s failed\n", DEF_DNS_CFG_FILE);
		return -1;
	}

	while(fgets(sline, sizeof(sline), fp) != NULL)  
	{  
		tmp =sline;  
		while(*tmp && isspace(*tmp)) { 
			++ tmp;  
		}
		if(strncmp(tmp, "nameserver", strlen("nameserver")) == 0)  {
			if(pPrimary[0] == 0){
				sscanf(sline, "nameserver %s", pPrimary);
			}else if(pSecond[0] == 0){
				sscanf(sline, "nameserver %s", pSecond);
			}
		}
	}  
	
	fclose(fp);
	return 0;
}

//set dns address
int set_dnsaddress(const char *pPrimary, const char *pSecond)
{
	return save_dns_info(pPrimary,pSecond);
}

int get_networkinfo(XLIB_NETWORKINFO *pNetInfo)
{
	if(NULL == pNetInfo){
		printf("NULL == pNetInfo");
		return -1;
	}

	strncpy((char*)pNetInfo->szEthName, "eth0", strlen("eth0"));
	
	if(get_localip((char *)pNetInfo->szEthName, (char*)pNetInfo->szIP, sizeof(pNetInfo->szIP)) < 0){
		printf("get_localip eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(get_localmac((char *)pNetInfo->szEthName, (char *)pNetInfo->szPhyAddr, sizeof(pNetInfo->szPhyAddr)) < 0){
		printf("get_localmac eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(get_netmask((char *)pNetInfo->szEthName, (char *)pNetInfo->szSubMsk,sizeof(pNetInfo->szSubMsk)) < 0){
		printf("get_netmask eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(get_gateway((char *)pNetInfo->szGateWay, sizeof(pNetInfo->szGateWay)) < 0){
		printf("get_gateway eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(get_dnsaddress((char *)pNetInfo->szFirstDns,sizeof(pNetInfo->szFirstDns), (char *)pNetInfo->szSecDns, sizeof(pNetInfo->szSecDns)) < 0){
		printf("get_dnsaddress eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}
	

	return 0;
}

int set_networkinfo(XLIB_NETWORKINFO *pNetInfo)
{
	if(NULL == pNetInfo){
		return -1;
	}

	strncpy((char*)pNetInfo->szEthName, "eth0", strlen("eth0"));

	if(set_localip((char *)pNetInfo->szEthName, (char *)pNetInfo->szIP) < 0){
		printf("set_localip eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(set_localmac((char *)pNetInfo->szEthName, (char *)pNetInfo->szPhyAddr) < 0){
		printf("set_localmac eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(set_netmask((char *)pNetInfo->szEthName, (char *)pNetInfo->szSubMsk) < 0){
		printf("set_netmask eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(set_gateway((char *)pNetInfo->szGateWay) < 0){
		printf("set_gateway eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}

	if(set_dnsaddress((char *)pNetInfo->szFirstDns,(char *)pNetInfo->szSecDns) < 0){
		printf("set_dnsaddress eth %s failed\n", (char *)pNetInfo->szEthName);
		return -1;
	}
	
	if(save_net_info(pNetInfo) < 0){
		printf("save_net_info failed\n" );
		return -1;	
	}

	return 0;
}

int set_network_manual(XLIB_NETWORKINFO *pNetInfo,XLIB_NETWORKINFO *pCurNetInfo)
{
	if(NULL == pNetInfo || NULL == pCurNetInfo){
		return -1;
	}
	if(0 != strcmp((char*)pNetInfo->szIP , (char*)pCurNetInfo->szIP)){
		if(set_localip((char*)pNetInfo->szEthName, (char*)pNetInfo->szIP) < 0){
			printf(" __on_set_net_info:set_localip failed!\n");
			return -1;
		}
		printf(" set_network_manual:set_gateway!\n");
		if(set_gateway((char*)pNetInfo->szGateWay) < 0){				//because set_localip: gateway -> "lo" 
			printf(" __on_set_net_info:set_gateway failed!\n");
			return -1;
		}
	}

	if(0 != strcmp((char*)pNetInfo->szSubMsk, (char*)pCurNetInfo->szSubMsk)){
		if(set_netmask((char*)pNetInfo->szEthName, (char*)pNetInfo->szSubMsk) < 0){
			printf(" __on_set_net_info:set_netmask failed!\n");
			return -1;
		}
		printf(" set_network_manual:set_gateway!\n");
		if(set_gateway((char*)pNetInfo->szGateWay) < 0){				//because set_netmask: gateway -> "lo" 
			printf(" __on_set_net_info:set_gateway failed!\n");
			return -1;
		}
	}

	if(0 != pNetInfo->phyaddrEnable && 0 != strcmp((char*)pNetInfo->szPhyAddr, (char*)pCurNetInfo->szPhyAddr)){
		if(set_localmac((char*)pNetInfo->szEthName, (char*)pNetInfo->szPhyAddr) < 0){
			printf(" __on_set_net_info:set_localmac failed!\n");
			return -1;
		}
	}

	if(0 != strncmp((char*)pNetInfo->szGateWay, (char*)pCurNetInfo->szGateWay, strlen((char*)pNetInfo->szGateWay))){
		if(set_gateway((char*)pNetInfo->szGateWay) < 0){
			printf(" __on_set_net_info:set_gateway failed!\n");
			return -1;
		}
	}

	if(0 != strcmp((char*)pNetInfo->szFirstDns, (char*)pCurNetInfo->szFirstDns) ||
		0 != strcmp((char*)pNetInfo->szSecDns, (char*)pCurNetInfo->szSecDns)){
		if(set_dnsaddress((char*)pNetInfo->szFirstDns, (char*)pNetInfo->szSecDns) < 0){
			printf(" __on_set_net_info:set_dnsaddress failed!\n");
			return -1;
		}
	}

	if(save_net_info(pNetInfo) < 0){
		printf("__on_set_net_info :save_net_info failed!\n");
		return -1;
	}
	return 0;
}
int set_network_dhcp(XLIB_NETWORKINFO *pNetInfo,XLIB_NETWORKINFO *pCurNetInfo)
{
	if(NULL == pNetInfo || NULL == pCurNetInfo){
		return -1;
	}

	if(save_net_info(pNetInfo) < 0){
		printf("__on_set_net_info :save_net_info failed!\n");
		return -1;
	}
	if(set_localdhcp() < 0){
		printf(" __on_set_net_info:set_dhcp failed!\n");
		return -1;
	}
	if(get_networkinfo(pNetInfo) < 0)
	{
		printf("__on_set_net_info:dhcp failed! -> static\n");
		if(resume_staticip(pCurNetInfo) < 0){
			printf(" __on_set_net_info:resume_staticip failed!\n");
			return -1;
		}
	}
	return 0;
}

int resume_staticip(XLIB_NETWORKINFO *pNetInfo)
{
	XLIB_NETWORKINFO netinfo;
	if(NULL == pNetInfo){
		return -1;
	}
	
	memcpy(&netinfo, pNetInfo, sizeof(XLIB_NETWORKINFO));
	netinfo.dhcpEnable = 0;
/*	
	if(set_net_cfg(&netinfo) < 0){
		printf("__on_set_net_info:set_net_cfg failed!\n");
		return -1;
	}
*/	
	if(set_networkinfo(&netinfo) < 0){
		printf(" __on_set_net_info:set_networkinfo failed!\n");
		return -1;
	}

	return 0;
}

